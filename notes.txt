Ideas on creating actual, mappable/mapped 2D dungeon:
- Each passage segment can be stored as a 2D text string representing the open spaces and connection points
- Or they could be represented by instruction, more dynamically handling things like passage width
- Chambers make a lot of sense handled dynamically, though non-rectangular rooms become quite tricky
- Could do both, having the trickier stuff be handled manually
- I need to be able to rotate whatever I end up with
- There probably needs to be a giant 2D array keeping track of everything, so collision detection can work out.
- Ideally there should also be a structure that keeps track of each room/corridor and linking doors, etc.
- I wonder if I should fish out some of my procedural home generation logic, as it did some similar stuff.


Connecting Passages:

Will the logic to add new passages be from map objects or the map? They will be in relation to both.
A map knows all of its objects. What we need to do when adding a passage is:
- Place the connector on the map
- Create the passage
- Rotate the passage as necessary
- Draw the passage on the map
This could be a problem. The passage needs to know what it will collide with *as it is being drawn* so it can
shorten its length to accommodate. Can we rotate as necessary prior to drawing?
Should be easy, just gotta set the cursor starting position and facing appropriately.
But the passage has to simultaneously understand the current cursor in relation to the map object grid and
the map grid at the same time. If a beginning relationship is established this should be possible.
Perhaps that relationship is established from the initial placement of the cursor? Perhaps the cursor could
get map_x and map_y functions that can use that relationship, so the cursor can tell you its position from
either reference.

Thinking this through:

On a 2-width passage pointing East, a cursor's initial coordinates are (-1, 10) (this will change based on width but we can account for this)
Let's say this is placed on the map at (15,15). Let's call the cursor's offset (16, 5) and see what happens.
This means (x, y) on the cursor returns (-1, 10),
and (map_x, map_y) returns (15, 15) if those functions just add the offset.
Let's say the cursor then goes forward 1 space. coordinates are (0,10) now, map coordinates are (16,15). I think that works.

It's important to note, though, that the relationship changes if/when we compact the map object.
What if we started compact? As in, each passage dictating size and starting coordinates? Well let's think about whether that's necessary.
The map primarily needs to be able to draw the object. It can only do that if it has an accurate offset.
If we compact, that necessarily changes the offset.
But offset from what? The cursor's offset isn't exactly what we want; we don't want to retrace all the steps in the map object, we want to transplant
the map object's grid onto the map. So we want the offset of the upper-left square of the map object.
Let's say we put the cursor to (0,0) on the map object. The offset (16, 5) would imply that (0,0) on the map_object is (16, 5) on the map.
Is that true? Yes, I believe it is. So the cursor offset and the map_object offset are one and the same.
So let's not compact, but maybe allow a smaller 
We may ultimately want to compact the map itself, though we may run into similar problems.
Setting length and width would have to assume max passage width (40?), and there is no way to set starting coordinates in the yaml because it depends
on width (not to mention facing).

When adding a new passage to the map, it needs an x and y, either given directly or figured out through the connector.
This needs to be the connector coordinates.

On to chambers. Chambers have a defined width and length.
Similarly to passages, chambers must be shrunk if a side would collide with something.
I think it needs to use cursors just like passages, essentially acting like really wide passages.
With passages, I can get away with just shortening the one end.
With chambers, I should think about each side, potentially even shifting instead of shrinking, for it to fit.
Additionally, figuring out the position of doors and connectors will be more challenging than with passages.
And then non-rectangular shapes will be a nightmare.

Chambers can have an exact map object grid size if I want. Whether I do want that depends on how I handle the fitting of the chamber.
To place the chamber (centered? right-aligned? left-aligned? random?) do I tinker with the wall boundaries in the map object,
or do I tinker with the map offsets?
Unlike with passages, I think the spacing needs to be figured out before the drawing starts, not during.
I could have the map do this, and have the map figure out and provide the cursor offset.
But the cursor is the easiest way to do that check, which the map has yet to have to use.

Figuring out what to shrink and shift intelligently is actually fairly tricky. When do you reduce length? When do you reduce width?
Having simple clearance number results can give you an extremely rudimentary solution that will likely do silly things from time to time.

When do I figure out what to prefer in terms of starting point relative to the new chamber? Could always prefer centered, or randomize it at the
beginning. The placing algorithm depends on it. I'll start by preferring centered, that will likely get the best, if slightly predictable, results.

START
Probe outward from starting point
CLEAR
  Probe outward 1/2 width in both directions
  CLEAR
    Draw chamber; Done
  BLOCKED
    Get distance to blocked in both directions
    LOOP
BLOCKED
  Reduce chamber length until not blocked
  If length < 15 ft, cancel room
  Start over

So far this has been somewhat helpful, but what if I gather a bunch of data instead of doing this exploratory probing and such?
For each point from starting point to length of room, probe width-wise in both directions and get distances.
The primary goal as we walk the algorithm is to figure out room size that is as large as possible, up to its original intended size.
A secondary design goal is to minimize small gaps between objects; aligning objects to other objects is preferred.
The below algorithm, in the case of a conflict, produce many chamber proposals and then decide between them.
Stop if the point out from the starting point is actively blocked, and reduce length of room accordingly.
Check if all distances are at least 1/2 width. If they are, the room needs no shifting or shrinking and can be placed.
Now walk through from beginning to end. Look at the two side distances for that length point.
For each point:
  If both distances are at least 1/2 width, skip; we already know we can't do the normal unshifted room so this gives us no info.
  If the sum of the distances are less than width, add a chamber proposal with the reduced width if possible.
  If the sum of the distances are width or more, add a chamber proposal for each of (sum - width), each one a shifted version of the chamber, skipping impossible proposals
  NOTE: Track number of alignment points each proposal has, for weighting purposes.
Find the largest possible chamber from the proposals. In the case of a tie, choose the one with the largest number of alignment points.

When proposing a chamber:
  Start with how far up and down from your length point you are drawing the chamber.
  Draw that same width back to the starting point. If any are impossible, abort.
  Draw that same width outward until either the length is reached, or an obstacle is hit. If an obstacle is hit, reduce length accordingly.
  Record beginning-left point, width, length, and number of alignments.

(Note: resolved) WARNING: The above doesn't take into account the fact that connectors are going to be 2 squares or more wide. The main difference is how far we look in each direction, and how many proposals get created per point in length.
To get width out: First, subtract entrance width from chamber width. If the result is negative, we need to decide what to do with that (fail for now)
For the remainder, divide that by 2. Look that number left, and connector width + that right. If odd, give left (or better, random) the extra square.
In addition, when doing the initial check, I need to check out from all parts of the connector width.

On giving a chamber the proper information to be able to draw it in the correct spot:
The chamber needs to line up such that the entrance comes right before the decided-on point of contact.
How do we get that point? Well we have left and right widths. If we shift a cursor right equal to the left width, we should get that point.
But then how does that translate to the correct map offsets?

........
........
..xxxx..
##xxxx..
##xxxx..
..xxxx..
........
........

This is a 4x4 room with a left width of 1. The left entrance coordinate is (1,3). The map offset for the chamber is (2,2). (note: bad logic ->) Well actually (1,2) because it starts before the first drawn coordinate. So to get the offset, we start with the left entrance coordinate, and shift left the distance of the left width. Which is obvious in retrospect.
The problem is that we aren't currently working with cursors; we simply have x and y coordinates.
I'm currently using initial_cursor_pos, which gets the x and y on the chamber grid in which the cursor starts. In the above example, initial cursor coordinates are (-1, 0). I'm going to use another example to gain perspective.

........
........
..xxxx..
..xxxx##
..xxxx##
..xxxx..
........
........

4x4 room, left width 1, left entrance coordinate is (6,4) on the map grid. Initial cursor coordinates are (4,3) on the chamber grid. Map offset should be (2,2), as it should've been in the first example - I forgot that the map offset is a very simple translator from chamber grid to map grid, nothing to do with cursor or starting before the first drawn coordinate.
The first example is really left entrance minus initial cursor coordinates, then shifted left equal to left width.
Second example should be too. So (6,4) - (4,3) = (2,1), shifted left 1 while facing West = (2,2). Correct.
So either I need annoying math to add or subtract the right number, or I can create a temporary cursor since my cursor logic already does that.
I created a temporary cursor and am now to the point where the place-as-is part seems to work.

How does the algorithm handle an issue like this?

#####.......
#####.......
............
............
#...........
#...........
............
.......#####
.......#####
..##...#####
..##...#####
..##........

Attempting to position a room width 6 length 8 at the end of the passage shown.
1: 
  Left distance < half width
  Sum of distances >= width; adding (sum - width) proposals: (2 + 6) - 6 = 2 proposals. There should be 3.

What is it missing? Maybe it meant passage width, but if so that's still wrong.
In this case it's from 0 to left distance - 0, 1, and 2. If right width were, say, 5, it'd be just 1 and 2 left.
Maybe it's (left distance + 1) - (width - right distance). That's (2+1)-(6-4) = 1. Still don't got it.
No, I must've been mostly right the first time, I just forgot that the two distances don't include the square it starts on, so it's + 1.
Dammit it still doesn't work when adding the right distance limitation - the proposals get reduced by 2 instead of 1.
The problem is it shouldn't be checking all 6 squares to the right, only 5.
It should be checking (width - passage width) to the left and (width - 1) to the right.
So that sum would be 2 + 5 here, or 4 + 5 if it were totally open. If totally open, there would be 5 options.
Gotta get back to this.
Let's try: sum - (width - entrance_width)
All open: 4 + 5 - (6 - 2)  = 9 - 4 = 5
Current example: 2 + 5 - (6 - 2) = 7 - 4 = 3
With extra obstacle: 2 + 4 - (6 - 2) = 6 - 4 = 2
If it were a 4-width passage: 2 + 4 - (6 - 4) = 4. Should actually be 2.
4-width passage that is open: 4 + 5 - (6 - 4) = 7. Should actually be 3.
Nope that doesn't work. Increased passage width should either not change it, or reduce options if the left side is open.
The algorithm just isn't simple enough to be condensed to such a basic arithmetic solution; impacts depend on right vs left.
Hold on - what about minimum of (left width from connector + 1, right width from connector + 1)?
All open: min(4+1, 4+1) = 5
Current example: min(2+1, 4+1) = 3
Withe extra obstacle: min(2+1, 3+1) = 3. Ugh, nope still not worky. In reality, the obstacle to the right impacts the possibilities to the left.
Oh yeah, let's revisit this: "If both distances are at least 1/2 width, skip"
Is that still true given the new distance maxes? I don't think it's quite right.
What I'm really trying to say is, "is it possible to draw the chamber centered here?"


Let's try this again:

1: 
  Left distance < half width
  Sum of distances >= width; adding (sum + 1 - width) proposals: (2 + 6 + 1) - 6 = 3 proposals.
  Proposal 1: start left 2; width 6, length 5, align 2
  Proposal 2: start left 1; width 6, length 5, align 1
  Proposal 3: start left 0; width 6, length 5, align 1

Coming back to this after a hiatus. What the heck do I mean about sum of distances? The passage width crucially affects this.
Logic through... Start by pretending the easiest scenario and then add in each complication.
Best case, our proposals are gotten by starting where the room is aligned to the right edge of the entrance and ending where it's aligned to left.
For width 4, entrance width 2, that's 3 proposals. For width 5 that's 4 proposals and so on.
So for that simple model (width + 1 - pwidth) is a working algorithm. Every point of width adds an opportunity, every pwidth restricts it.
The "+1" option is the zero-shift option.
Now let's add in obstacles. Let's go back to width 6. and assume the Northern obstacle in the test situation above.
That takes the proposals from 5 to 3. For every space away from the left passage edge it increases proposals to a max of 5.
Every space closer, it decreases them to a min of 1. Determining factor is that distance between it and the left edge.
Distance below 0 doesn't matter. Distance above (width - pwidth) doesn't matter
So it reduces proposals by  min(1, min(empty_spaces_from_entrance, width - pwidth))
But of course then there is the right side, and the two sides can interact with each other.
Let's assume the 2nd length point in the above picture, where an obstacle sits 4 spaces away from the right edge.
Let's try using the same formula.
min(1, min(empty_spaces_from_entrance, width - pwidth)) = min(1, min(3, 6 - 2)) = 3. Nope can't do it that simply (it should be 1) 
Wait I got things twisted around; distance from entrance should increase possibilities, not reduce them.
Also doing the two subtractions doesn't make sense; you can limit the proposals down to 1 from the left side and then it ceases
to matter what the right side looks like. Wait that's not true, if the right side also reduces possibilities, that reduces length.
So maybe subtractions are right.
(width - pwidth) - clear spaces from entrance is what determines how much  is reduced.
or better: width - min(clear_spaces_from_right_entrance_edge, width)

Full Algorithm: (width + 1 - pwidth) - (width - min(clear_left + pwidth, width)) - (width - min(clear_right + pwidth, width))

Let's assume width 6 pwidth 2, adding in obstacles from the example above
No obstacles: (width + 1 - pwidth) = 6 + 1 - 2 = 5
Left obstacle: (width + 1 - pwidth) - (width - min(clear_spaces_from_entrance_right)) = (6 + 1 - 2) - (6 - (2 + 2)) = 5 - 2 = 3
Right obstacle: (width + 1 - pwidth) - (width - min(clear_spaces_from_entrance_left)) = (6 + 1 - 2) - (6 - (2 + 3)) = 5 - 1 = 4
Both obstacles: (width + 1 - pwidth) - (width - min(clear_spaces_from_entrance_right)) - (width - min(clear_spaces_from_entrance_left)) 
   = (6 + 1 - 2) - (6 - (2 + 2)) - (6 - (2 + 3)) = 5 - 2 - 1 = 2
That's correct! Now we're getting somewhere. Let's say there are obstacles directly on each side of the entrance. You'd get:
5 - (6-2) - (6-2) = -3. The width is 6 but can only support 2. The reason it's -3 and not -4 is that there are 4 fewer than 1 options.

Okay, *now* we're ready for a logical walkthrough.

#####.......
#####.......
............
............
#...........
#...........
............
.......#####
.......#####
..##...#####
..##...#####
..##........


1:
  Obstacles?:        Yes, Left distance < half width
  Clearance:         (2, 6)
  Proposals:         5 - 2 - 0 = 3
  Proposal 1:        start left 2; width 6, length 5, align 7
  Proposal 2:        start left 1; width 6, length 5, align 4
  Proposal 3:        start left 0; width 6, length 1, align 2 -> align 3
2:
  Obstacles?:        Yes, Right distance < half width
  Clearance:         (2, 3)
  Proposals:         5 - 2 - 1 = 2
  Proposal 1:        start left 2; width 6, length 5, align 7
  Proposal 2:        start left 1; width 6, length 5, align 4
3:
  Obstacles?:        Yes, Right distance < half width
  Clearance:         (2, 3)
  Proposals:         5 - 2 - 1 = 2
  Proposal 1:        start left 2; width 6, length 5, align 7
  Proposal 2:        start left 1; width 6, length 5, align 4
4:
  Obstacles?:        Yes, Left distance < half width
  Clearance:         (2, 6)
  Proposals:         5 - 2 - 0 = 3
  Proposal 1:        start left 2; width 6, length 5, align 7
  Proposal 2:        start left 1; width 6, length 5, align 4
  Proposal 3:        start left 0; ABORT (cannot trace back to start) -> left 0, width 5, length 5, align 5
5:
  Obstacles?:        No
6:
  Obstacles?:        No
7:
  Obstacles?:        Yes, Right distance < half width
  Clearance:         (6, 1)
  Proposals:         5 - 0 - 3 = 2
  Proposal 1:        start left 4; ABORT (cannot trace back to start) -> left 2, width 4, length 8, align 4
  Proposal 2:        start left 3; ABORT (cannot trace back to start) -> left 2, width 5, length 8, align 6
8:
  Obstacles?:        Yes, Right distance < half width
  Clearance:         (6, 1)
  Proposals:         5 - 0 - 3 = 2
  Proposal 1:        start left 4; ABORT (cannot trace back to start) -> left 2, width 4, length 8, align 4
  Proposal 2:        start left 3; ABORT (cannot trace back to start) -> left 2, width 5, length 8, align 6

The winning proposal will be left 2, width 6, length 5.
A proposal that would have won if it were considered would have been left 2, width 5, length 8.
A more minor note: The algorith could reasonably look up whether a proposal of a certain nature already exists before adding it again.
How to make it just a little smarter? Maybe have it look deeper on cases where it would abort.
The aborts will always be width-related. So what I would do instead of aborting:
  Draw the room with the specified length and left. When an obstacle is found to the left of the entrance, change width and left to get past it.
  When an obstacle is found to the right of the entrance, change width to get past it.
  I am adding the results of the new logic to all the abort lines above.
I should also add an align bonus if left is max or 0.
And align_weight and area_weight should be configurable, as well configuration around randomly choosing less optimal positionings.

---

......
......
....++
......
......
------
......
+++...
......
......
......


Currently, there is a bug in the algorithm where, if there isn't enough width for a given point, no proposals are attempted. This is bad because it can lead to scenarios where the algorithm could refuse to place a room in consistently-cramped-enough quarters, instead of creating a smaller room. What it should do is, if it doesn't have enough width, create one proposal that fills the entirety of the width that's available.

Next task is getting it all connected together. Some tasks related to this:
* Have doors and connectors inherit from a parent (probably)
* Figure out algorithm to go from nothing to full dungeon
* Lots of generation logic
* Logic for figuring out where doors/connectors go in a chamber, and logic to replace those parts of the wall

Starting area is hard. Let's simplify it to a passage for now.


The macro algorithm:

Start by creating a "starting area". Technically this should use a custom starting-room roll, based on the DMG. It might be a chamber or a passage.
  Determine starting location and facing for this area. Consider making this entirely random, or just slap it in the center or on a side.
Generate exits. For a passage this is figured out already. For a chamber, roll chamber exits, and location and type for each.

Project tracking:

- Passage Instructions: 75%
-- Chance of secret door
-- Chamber
-- Stairs
- Connecting Passages: 10%
-- Connect logically
-- Connect physically on map
- Putting passages on map: 20%
- Collision handling: 10%
