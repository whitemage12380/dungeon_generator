Ideas on creating actual, mappable/mapped 2D dungeon:
- Each passage segment can be stored as a 2D text string representing the open spaces and connection points
- Or they could be represented by instruction, more dynamically handling things like passage width
- Chambers make a lot of sense handled dynamically, though non-rectangular rooms become quite tricky
- Could do both, having the trickier stuff be handled manually
- I need to be able to rotate whatever I end up with
- There probably needs to be a giant 2D array keeping track of everything, so collision detection can work out.
- Ideally there should also be a structure that keeps track of each room/corridor and linking doors, etc.
- I wonder if I should fish out some of my procedural home generation logic, as it did some similar stuff.


Connecting Passages:

Will the logic to add new passages be from map objects or the map? They will be in relation to both.
A map knows all of its objects. What we need to do when adding a passage is:
- Place the connector on the map
- Create the passage
- Rotate the passage as necessary
- Draw the passage on the map
This could be a problem. The passage needs to know what it will collide with *as it is being drawn* so it can
shorten its length to accommodate. Can we rotate as necessary prior to drawing?
Should be easy, just gotta set the cursor starting position and facing appropriately.
But the passage has to simultaneously understand the current cursor in relation to the map object grid and
the map grid at the same time. If a beginning relationship is established this should be possible.
Perhaps that relationship is established from the initial placement of the cursor? Perhaps the cursor could
get map_x and map_y functions that can use that relationship, so the cursor can tell you its position from
either reference.

Thinking this through:

On a 2-width passage pointing East, a cursor's initial coordinates are (-1, 10) (this will change based on width but we can account for this)
Let's say this is placed on the map at (15,15). Let's call the cursor's offset (16, 5) and see what happens.
This means (x, y) on the cursor returns (-1, 10),
and (map_x, map_y) returns (15, 15) if those functions just add the offset.
Let's say the cursor then goes forward 1 space. coordinates are (0,10) now, map coordinates are (16,15). I think that works.

It's important to note, though, that the relationship changes if/when we compact the map object.
What if we started compact? As in, each passage dictating size and starting coordinates? Well let's think about whether that's necessary.
The map primarily needs to be able to draw the object. It can only do that if it has an accurate offset.
If we compact, that necessarily changes the offset.
But offset from what? The cursor's offset isn't exactly what we want; we don't want to retrace all the steps in the map object, we want to transplant
the map object's grid onto the map. So we want the offset of the upper-left square of the map object.
Let's say we put the cursor to (0,0) on the map object. The offset (16, 5) would imply that (0,0) on the map_object is (16, 5) on the map.
Is that true? Yes, I believe it is. So the cursor offset and the map_object offset are one and the same.
So let's not compact, but maybe allow a smaller 
We may ultimately want to compact the map itself, though we may run into similar problems.
Setting length and width would have to assume max passage width (40?), and there is no way to set starting coordinates in the yaml because it depends
on width (not to mention facing).

When adding a new passage to the map, it needs an x and y, either given directly or figured out through the connector.
This needs to be the connector coordinates.

On to chambers. Chambers have a defined width and length.
Similarly to passages, chambers must be shrunk if a side would collide with something.
I think it needs to use cursors just like passages, essentially acting like really wide passages.
With passages, I can get away with just shortening the one end.
With chambers, I should think about each side, potentially even shifting instead of shrinking, for it to fit.
Additionally, figuring out the position of doors and connectors will be more challenging than with passages.
And then non-rectangular shapes will be a nightmare.

Chambers can have an exact map object grid size if I want. Whether I do want that depends on how I handle the fitting of the chamber.
To place the chamber (centered? right-aligned? left-aligned? random?) do I tinker with the wall boundaries in the map object,
or do I tinker with the map offsets?
Unlike with passages, I think the spacing needs to be figured out before the drawing starts, not during.
I could have the map do this, and have the map figure out and provide the cursor offset.
But the cursor is the easiest way to do that check, which the map has yet to have to use.

Figuring out what to shrink and shift intelligently is actually fairly tricky. When do you reduce length? When do you reduce width?
Having simple clearance number results can give you an extremely rudimentary solution that will likely do silly things from time to time.

When do I figure out what to prefer in terms of starting point relative to the new chamber? Could always prefer centered, or randomize it at the
beginning. The placing algorithm depends on it. I'll start by preferring centered, that will likely get the best, if slightly predictable, results.

START
Probe outward from starting point
CLEAR
  Probe outward 1/2 width in both directions
  CLEAR
    Draw chamber; Done
  BLOCKED
    Get distance to blocked in both directions
    LOOP
BLOCKED
  Reduce chamber length until not blocked
  If length < 15 ft, cancel room
  Start over

So far this has been somewhat helpful, but what if I gather a bunch of data instead of doing this exploratory probing and such?
For each point from starting point to length of room, probe width-wise in both directions and get distances.
The primary goal as we walk the algorithm is to figure out room size that is as large as possible, up to its original intended size.
A secondary design goal is to minimize small gaps between objects; aligning objects to other objects is preferred.
The below algorithm, in the case of a conflict, produce many chamber proposals and then decide between them.
Stop if the point out from the starting point is actively blocked, and reduce length of room accordingly.
Check if all distances are at least 1/2 width. If they are, the room needs no shifting or shrinking and can be placed.
Now walk through from beginning to end Look at the two distances for that length point.
For each point:
  If both distances are at least 1/2 width, skip; we already know we can't do the normal unshifted room so this gives us no info.
  If the sum of the distances are less than width, add a chamber proposal with the reduced width if possible.
  If the sum of the distances are width or more, add a chamber proposal for each of (sum - width), each one a shifted version of the chamber, skipping impossible proposals
  NOTE: Track number of alignment points each proposal has, for weighting purposes.
Find the largest possible chamber from the proposals. In the case of a tie, choose the one with the largest number of alignment points.

When proposing a chamber:
  Start with how far up and down from your length point you are drawing the chamber.
  Draw that same width back to the starting point. If any are impossible, abort.
  Draw that same width outward until either the length is reached, or an obstacle is hit. If an obstacle is hit, reduce length accordingly.
  Record beginning-left point, width, length, and number of alignments.

(Note: resolved) WARNING: The above doesn't take into account the fact that connectors are going to be 2 squares or more wide. The main difference is how far we look in each direction, and how many proposals get created per point in length.
To get width out: First, subtract entrance width from chamber width. If the result is negative, we need to decide what to do with that (fail for now)
For the remainder, divide that by 2. Look that number left, and connector width + that right. If odd, give left (or better, random) the extra square.
In addition, when doing the initial check, I need to check out from all parts of the connector width.

On giving a chamber the proper information to be able to draw it in the correct spot:
The chamber needs to line up such that the entrance comes right before the decided-on point of contact.
How do we get that point? Well we have left and right widths. If we shift a cursor right equal to the left width, we should get that point.
But then how does that translate to the correct map offsets?

........
........
..xxxx..
##xxxx..
##xxxx..
..xxxx..
........
........

This is a 4x4 room with a left width of 1. The left entrance coordinate is (1,3). The map offset for the chamber is (2,2). (note: bad logic ->) Well actually (1,2) because it starts before the first drawn coordinate. So to get the offset, we start with the left entrance coordinate, and shift left the distance of the left width. Which is obvious in retrospect.
The problem is that we aren't currently working with cursors; we simply have x and y coordinates.
I'm currently using initial_cursor_pos, which gets the x and y on the chamber grid in which the cursor starts. In the above example, initial cursor coordinates are (-1, 0). I'm going to use another example to gain perspective.

........
........
..xxxx..
..xxxx##
..xxxx##
..xxxx..
........
........

4x4 room, left width 1, left entrance coordinate is (6,4) on the map grid. Initial cursor coordinates are (4,3) on the chamber grid. Map offset should be (2,2), as it should've been in the first example - I forgot that the map offset is a very simple translator from chamber grid to map grid, nothing to do with cursor or starting before the first drawn coordinate.
The first example is really left entrance minus initial cursor coordinates, then shifted left equal to left width.
Second example should be too. So (6,4) - (4,3) = (2,1), shifted left 1 while facing West = (2,2). Correct.
So either I need annoying math to add or subtract the right number, or I can create a temporary cursor since my cursor logic already does that.
I created a temporary cursor and am now to the point where the place-as-is part seems to work.


---

......
......
....++
......
......
------
......
+++...
......
......
......

Project tracking:

- Passage Instructions: 75%
-- Chance of secret door
-- Chamber
-- Stairs
- Connecting Passages: 10%
-- Connect logically
-- Connect physically on map
- Putting passages on map: 20%
- Collision handling: 10%
