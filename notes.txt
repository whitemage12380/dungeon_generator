Ideas on creating actual, mappable/mapped 2D dungeon:
- Each passage segment can be stored as a 2D text string representing the open spaces and connection points
- Or they could be represented by instruction, more dynamically handling things like passage width
- Chambers make a lot of sense handled dynamically, though non-rectangular rooms become quite tricky
- Could do both, having the trickier stuff be handled manually
- I need to be able to rotate whatever I end up with
- There probably needs to be a giant 2D array keeping track of everything, so collision detection can work out.
- Ideally there should also be a structure that keeps track of each room/corridor and linking doors, etc.
- I wonder if I should fish out some of my procedural home generation logic, as it did some similar stuff.


Connecting Passages:

Will the logic to add new passages be from map objects or the map? They will be in relation to both.
A map knows all of its objects. What we need to do when adding a passage is:
- Place the connector on the map
- Create the passage
- Rotate the passage as necessary
- Draw the passage on the map
This could be a problem. The passage needs to know what it will collide with *as it is being drawn* so it can
shorten its length to accommodate. Can we rotate as necessary prior to drawing?
Should be easy, just gotta set the cursor starting position and facing appropriately.
But the passage has to simultaneously understand the current cursor in relation to the map object grid and
the map grid at the same time. If a beginning relationship is established this should be possible.
Perhaps that relationship is established from the initial placement of the cursor? Perhaps the cursor could
get map_x and map_y functions that can use that relationship, so the cursor can tell you its position from
either reference.

Thinking this through:

On a 2-width passage pointing East, a cursor's initial coordinates are (-1, 10) (this will change based on width but we can account for this)
Let's say this is placed on the map at (15,15). Let's call the cursor's offset (16, 5) and see what happens.
This means (x, y) on the cursor returns (-1, 10),
and (map_x, map_y) returns (15, 15) if those functions just add the offset.
Let's say the cursor then goes forward 1 space. coordinates are (0,10) now, map coordinates are (16,15). I think that works.

It's important to note, though, that the relationship changes if/when we compact the map object.
What if we started compact? As in, each passage dictating size and starting coordinates? Well let's think about whether that's necessary.
The map primarily needs to be able to draw the object. It can only do that if it has an accurate offset.
If we compact, that necessarily changes the offset.
But offset from what? The cursor's offset isn't exactly what we want; we don't want to retrace all the steps in the map object, we want to transplant
the map object's grid onto the map. So we want the offset of the upper-left square of the map object.
Let's say we put the cursor to (0,0) on the map object. The offset (16, 5) would imply that (0,0) on the map_object is (16, 5) on the map.
Is that true? Yes, I believe it is. So the cursor offset and the map_object offset are one and the same.
So let's not compact, but maybe allow a smaller 
We may ultimately want to compact the map itself, though we may run into similar problems.
Setting length and width would have to assume max passage width (40?), and there is no way to set starting coordinates in the yaml because it depends
on width (not to mention facing).

When adding a new passage to the map, it needs an x and y, either given directly or figured out through the connector.
This needs to be the connector coordinates.

On to chambers. Chambers have a defined width and length.
Similarly to passages, chambers must be shrunk if a side would collide with something.
I think it needs to use cursors just like passages, essentially acting like really wide passages.
With passages, I can get away with just shortening the one end.
With chambers, I should think about each side, potentially even shifting instead of shrinking, for it to fit.
Additionally, figuring out the position of doors and connectors will be more challenging than with passages.
And then non-rectangular shapes will be a nightmare.

Chambers can have an exact map object grid size if I want. Whether I do want that depends on how I handle the fitting of the chamber.
To place the chamber (centered? right-aligned? left-aligned? random?) do I tinker with the wall boundaries in the map object,
or do I tinker with the map offsets?
Unlike with passages, I think the spacing needs to be figured out before the drawing starts, not during.
I could have the map do this, and have the map figure out and provide the cursor offset.
But the cursor is the easiest way to do that check, which the map has yet to have to use.

Figuring out what to shrink and shift intelligently is actually fairly tricky. When do you reduce length? When do you reduce width?
Having simple clearance number results can give you an extremely rudimentary solution that will likely do silly things from time to time.

When do I figure out what to prefer in terms of starting point relative to the new chamber? Could always prefer centered, or randomize it at the
beginning. The placing algorithm depends on it. I'll start by preferring centered, that will likely get the best, if slightly predictable, results.

START
Probe outward from starting point
CLEAR
  Probe outward 1/2 width in both directions
  CLEAR
    Draw chamber; Done
  BLOCKED
    Get distance to blocked in both directions
    LOOP
BLOCKED
  Reduce chamber length until not blocked
  If length < 15 ft, cancel room
  Start over

So far this has been somewhat helpful, but what if I gather a bunch of data instead of doing this exploratory probing and such?
For each point from starting point to length of room, probe width-wise in both directions and get distances.
The primary goal as we walk the algorithm is to figure out room size that is as large as possible, up to its original intended size.
A secondary design goal is to minimize small gaps between objects; aligning objects to other objects is preferred.
The below algorithm, in the case of a conflict, produce many chamber proposals and then decide between them.
Stop if the point out from the starting point is actively blocked, and reduce length of room accordingly.
Check if all distances are at least 1/2 width. If they are, the room needs no shifting or shrinking and can be placed.
Now walk through from beginning to end. Look at the two side distances for that length point.
For each point:
  If both distances are at least 1/2 width, skip; we already know we can't do the normal unshifted room so this gives us no info.
  If the sum of the distances are less than width, add a chamber proposal with the reduced width if possible.
  If the sum of the distances are width or more, add a chamber proposal for each of (sum - width), each one a shifted version of the chamber, skipping impossible proposals
  NOTE: Track number of alignment points each proposal has, for weighting purposes.
Find the largest possible chamber from the proposals. In the case of a tie, choose the one with the largest number of alignment points.

When proposing a chamber:
  Start with how far up and down from your length point you are drawing the chamber.
  Draw that same width back to the starting point. If any are impossible, abort.
  Draw that same width outward until either the length is reached, or an obstacle is hit. If an obstacle is hit, reduce length accordingly.
  Record beginning-left point, width, length, and number of alignments.

(Note: resolved) WARNING: The above doesn't take into account the fact that connectors are going to be 2 squares or more wide. The main difference is how far we look in each direction, and how many proposals get created per point in length.
To get width out: First, subtract entrance width from chamber width. If the result is negative, we need to decide what to do with that (fail for now)
For the remainder, divide that by 2. Look that number left, and connector width + that right. If odd, give left (or better, random) the extra square.
In addition, when doing the initial check, I need to check out from all parts of the connector width.

On giving a chamber the proper information to be able to draw it in the correct spot:
The chamber needs to line up such that the entrance comes right before the decided-on point of contact.
How do we get that point? Well we have left and right widths. If we shift a cursor right equal to the left width, we should get that point.
But then how does that translate to the correct map offsets?

........
........
..xxxx..
##xxxx..
##xxxx..
..xxxx..
........
........

This is a 4x4 room with a left width of 1. The left entrance coordinate is (1,3). The map offset for the chamber is (2,2). (note: bad logic ->) Well actually (1,2) because it starts before the first drawn coordinate. So to get the offset, we start with the left entrance coordinate, and shift left the distance of the left width. Which is obvious in retrospect.
The problem is that we aren't currently working with cursors; we simply have x and y coordinates.
I'm currently using initial_cursor_pos, which gets the x and y on the chamber grid in which the cursor starts. In the above example, initial cursor coordinates are (-1, 0). I'm going to use another example to gain perspective.

........
........
..xxxx..
..xxxx##
..xxxx##
..xxxx..
........
........

4x4 room, left width 1, left entrance coordinate is (6,4) on the map grid. Initial cursor coordinates are (4,3) on the chamber grid. Map offset should be (2,2), as it should've been in the first example - I forgot that the map offset is a very simple translator from chamber grid to map grid, nothing to do with cursor or starting before the first drawn coordinate.
The first example is really left entrance minus initial cursor coordinates, then shifted left equal to left width.
Second example should be too. So (6,4) - (4,3) = (2,1), shifted left 1 while facing West = (2,2). Correct.
So either I need annoying math to add or subtract the right number, or I can create a temporary cursor since my cursor logic already does that.
I created a temporary cursor and am now to the point where the place-as-is part seems to work.

How does the algorithm handle an issue like this?

#####.......
#####.......
............
............
#...........
#...........
............
.......#####
.......#####
..##...#####
..##...#####
..##........

Attempting to position a room width 6 length 8 at the end of the passage shown.
1: 
  Left distance < half width
  Sum of distances >= width; adding (sum - width) proposals: (2 + 6) - 6 = 2 proposals. There should be 3.

What is it missing? Maybe it meant passage width, but if so that's still wrong.
In this case it's from 0 to left distance - 0, 1, and 2. If right width were, say, 5, it'd be just 1 and 2 left.
Maybe it's (left distance + 1) - (width - right distance). That's (2+1)-(6-4) = 1. Still don't got it.
No, I must've been mostly right the first time, I just forgot that the two distances don't include the square it starts on, so it's + 1.
Dammit it still doesn't work when adding the right distance limitation - the proposals get reduced by 2 instead of 1.
The problem is it shouldn't be checking all 6 squares to the right, only 5.
It should be checking (width - passage width) to the left and (width - 1) to the right.
So that sum would be 2 + 5 here, or 4 + 5 if it were totally open. If totally open, there would be 5 options.
Gotta get back to this.
Let's try: sum - (width - entrance_width)
All open: 4 + 5 - (6 - 2)  = 9 - 4 = 5
Current example: 2 + 5 - (6 - 2) = 7 - 4 = 3
With extra obstacle: 2 + 4 - (6 - 2) = 6 - 4 = 2
If it were a 4-width passage: 2 + 4 - (6 - 4) = 4. Should actually be 2.
4-width passage that is open: 4 + 5 - (6 - 4) = 7. Should actually be 3.
Nope that doesn't work. Increased passage width should either not change it, or reduce options if the left side is open.
The algorithm just isn't simple enough to be condensed to such a basic arithmetic solution; impacts depend on right vs left.
Hold on - what about minimum of (left width from connector + 1, right width from connector + 1)?
All open: min(4+1, 4+1) = 5
Current example: min(2+1, 4+1) = 3
Withe extra obstacle: min(2+1, 3+1) = 3. Ugh, nope still not worky. In reality, the obstacle to the right impacts the possibilities to the left.
Oh yeah, let's revisit this: "If both distances are at least 1/2 width, skip"
Is that still true given the new distance maxes? I don't think it's quite right.
What I'm really trying to say is, "is it possible to draw the chamber centered here?"


Let's try this again:

1: 
  Left distance < half width
  Sum of distances >= width; adding (sum + 1 - width) proposals: (2 + 6 + 1) - 6 = 3 proposals.
  Proposal 1: start left 2; width 6, length 5, align 2
  Proposal 2: start left 1; width 6, length 5, align 1
  Proposal 3: start left 0; width 6, length 5, align 1

Coming back to this after a hiatus. What the heck do I mean about sum of distances? The passage width crucially affects this.
Logic through... Start by pretending the easiest scenario and then add in each complication.
Best case, our proposals are gotten by starting where the room is aligned to the right edge of the entrance and ending where it's aligned to left.
For width 4, entrance width 2, that's 3 proposals. For width 5 that's 4 proposals and so on.
So for that simple model (width + 1 - pwidth) is a working algorithm. Every point of width adds an opportunity, every pwidth restricts it.
The "+1" option is the zero-shift option.
Now let's add in obstacles. Let's go back to width 6. and assume the Northern obstacle in the test situation above.
That takes the proposals from 5 to 3. For every space away from the left passage edge it increases proposals to a max of 5.
Every space closer, it decreases them to a min of 1. Determining factor is that distance between it and the left edge.
Distance below 0 doesn't matter. Distance above (width - pwidth) doesn't matter
So it reduces proposals by  min(1, min(empty_spaces_from_entrance, width - pwidth))
But of course then there is the right side, and the two sides can interact with each other.
Let's assume the 2nd length point in the above picture, where an obstacle sits 4 spaces away from the right edge.
Let's try using the same formula.
min(1, min(empty_spaces_from_entrance, width - pwidth)) = min(1, min(3, 6 - 2)) = 3. Nope can't do it that simply (it should be 1) 
Wait I got things twisted around; distance from entrance should increase possibilities, not reduce them.
Also doing the two subtractions doesn't make sense; you can limit the proposals down to 1 from the left side and then it ceases
to matter what the right side looks like. Wait that's not true, if the right side also reduces possibilities, that reduces length.
So maybe subtractions are right.
(width - pwidth) - clear spaces from entrance is what determines how much  is reduced.
or better: width - min(clear_spaces_from_right_entrance_edge, width)

Full Algorithm: (width + 1 - pwidth) - (width - min(clear_left + pwidth, width)) - (width - min(clear_right + pwidth, width))

Let's assume width 6 pwidth 2, adding in obstacles from the example above
No obstacles: (width + 1 - pwidth) = 6 + 1 - 2 = 5
Left obstacle: (width + 1 - pwidth) - (width - min(clear_spaces_from_entrance_right)) = (6 + 1 - 2) - (6 - (2 + 2)) = 5 - 2 = 3
Right obstacle: (width + 1 - pwidth) - (width - min(clear_spaces_from_entrance_left)) = (6 + 1 - 2) - (6 - (2 + 3)) = 5 - 1 = 4
Both obstacles: (width + 1 - pwidth) - (width - min(clear_spaces_from_entrance_right)) - (width - min(clear_spaces_from_entrance_left)) 
   = (6 + 1 - 2) - (6 - (2 + 2)) - (6 - (2 + 3)) = 5 - 2 - 1 = 2
That's correct! Now we're getting somewhere. Let's say there are obstacles directly on each side of the entrance. You'd get:
5 - (6-2) - (6-2) = -3. The width is 6 but can only support 2. The reason it's -3 and not -4 is that there are 4 fewer than 1 options.

Okay, *now* we're ready for a logical walkthrough.

#####.......
#####.......
............
............
#...........
#...........
............
.......#####
.......#####
..##...#####
..##...#####
..##........


1:
  Obstacles?:        Yes, Left distance < half width
  Clearance:         (2, 6)
  Proposals:         5 - 2 - 0 = 3
  Proposal 1:        start left 2; width 6, length 5, align 7
  Proposal 2:        start left 1; width 6, length 5, align 4
  Proposal 3:        start left 0; width 6, length 1, align 2 -> align 3
2:
  Obstacles?:        Yes, Right distance < half width
  Clearance:         (2, 3)
  Proposals:         5 - 2 - 1 = 2
  Proposal 1:        start left 2; width 6, length 5, align 7
  Proposal 2:        start left 1; width 6, length 5, align 4
3:
  Obstacles?:        Yes, Right distance < half width
  Clearance:         (2, 3)
  Proposals:         5 - 2 - 1 = 2
  Proposal 1:        start left 2; width 6, length 5, align 7
  Proposal 2:        start left 1; width 6, length 5, align 4
4:
  Obstacles?:        Yes, Left distance < half width
  Clearance:         (2, 6)
  Proposals:         5 - 2 - 0 = 3
  Proposal 1:        start left 2; width 6, length 5, align 7
  Proposal 2:        start left 1; width 6, length 5, align 4
  Proposal 3:        start left 0; ABORT (cannot trace back to start) -> left 0, width 5, length 5, align 5
5:
  Obstacles?:        No
6:
  Obstacles?:        No
7:
  Obstacles?:        Yes, Right distance < half width
  Clearance:         (6, 1)
  Proposals:         5 - 0 - 3 = 2
  Proposal 1:        start left 4; ABORT (cannot trace back to start) -> left 2, width 4, length 8, align 4
  Proposal 2:        start left 3; ABORT (cannot trace back to start) -> left 2, width 5, length 8, align 6
8:
  Obstacles?:        Yes, Right distance < half width
  Clearance:         (6, 1)
  Proposals:         5 - 0 - 3 = 2
  Proposal 1:        start left 4; ABORT (cannot trace back to start) -> left 2, width 4, length 8, align 4
  Proposal 2:        start left 3; ABORT (cannot trace back to start) -> left 2, width 5, length 8, align 6

The winning proposal will be left 2, width 6, length 5.
A proposal that would have won if it were considered would have been left 2, width 5, length 8.
A more minor note: The algorith could reasonably look up whether a proposal of a certain nature already exists before adding it again.
How to make it just a little smarter? Maybe have it look deeper on cases where it would abort.
The aborts will always be width-related. So what I would do instead of aborting:
  Draw the room with the specified length and left. When an obstacle is found to the left of the entrance, change width and left to get past it.
  When an obstacle is found to the right of the entrance, change width to get past it.
  I am adding the results of the new logic to all the abort lines above.
I should also add an align bonus if left is max or 0.
And align_weight and area_weight should be configurable, as well configuration around randomly choosing less optimal positionings.

---

......
......
....++
......
......
------
......
+++...
......
......
......


Currently, there is a bug in the algorithm where, if there isn't enough width for a given point, no proposals are attempted. This is bad because it can lead to scenarios where the algorithm could refuse to place a room in consistently-cramped-enough quarters, instead of creating a smaller room. What it should do is, if it doesn't have enough width, create one proposal that fills the entirety of the width that's available.

Next task is getting it all connected together. Some tasks related to this:
* Have doors and connectors inherit from a parent (probably)
* Figure out algorithm to go from nothing to full dungeon
* Lots of generation logic
* Logic for figuring out where doors/connectors go in a chamber, and logic to replace those parts of the wall

Starting area is hard. Let's simplify it to a passage for now.


The macro algorithm:

Start by creating a "starting area". Technically this should use a custom starting-room roll, based on the DMG. It might be a chamber or a passage.
  Determine starting location and facing for this area. Consider making this entirely random, or just slap it in the center or on a side.
Generate exits. For a passage this is figured out already. For a chamber, roll chamber exits, and location and type for each.


Rolling chamber exits. I need to create a yaml file or two. It rolls for location, and then I need to decide where on the wall to put it.
In order to do this, I need to understand the width. For doors this is easy; for passages it is more challenging because that needs to be generated. Maybe not too tough; it isn't actually the passage width that needs to be determined, it's the connector width. And then later when passages are generated, the passage gets to use the connector width.
Best thought for algorithm is to figure out how many positions are possible and weight them:
- Possibly higher weight for central passage
- Higher weight if there's a room or passage on the other side, so it can connect
- Disallow if part of the door/connector leads to room/passage, and another part leads to empty space

Most connectors are 1-way, and when two map objects connect, they use separate connectors butting up against each other. The special exception is the starting connector for map objects; this connector is passed from the originating map object to the new one, and both objects draw the same connector in slightly different places. The originating object's location is the canonical connector location.

---------------

Chamber contents:
Monster: name, motivation (don't forget monsters are actually monster groups!)
Hazard, Obstacle: description
Trap: trigger, severity, effect
Trick: object, effect

---------------

Building encounters:
Option 1:
  Pull n encounters from the table
  For each encounter, create monsters and figure out if they physically fit
  UGH not continuing this approach, much more complex and lots of duplicated logic
Option 2:
  Pull n encounters from the table
  Create the encounters
  Throw away any encounters with 0 monsters
  Give encounters probabilities:
    - Total XP higher than max xp threshold: 1
    - XP threshold does not match target: 2
    - XP threshold matches target: 3
  Repeat this if there are 2 monster groups for the encounter
  Merge second monster group into first encounter

IMPORTANT: Do I involve monster group probability instead of the flat 3-2-1 probability above? Probably. Min 1.

---------------

Strategies for treasure:
Option 1:
  Directly from the DMG. Create a hoard beforehand. Once dungeon is built, distribute treasure. I usually try to adhere as closely as possible to the DMG randomization, but this is kind of a boring approach. In most cases there would be either instances from a single magic item table, or no magic items at all. However, the DMG does propose you can roll several hoards to distribute.
Option 2:
  Find or produce random treasure tables to use in each treasure spot
  Optional "mundane" item tables
  Have "TreasureStash" objects. More than one can exist in a chamber.
  Improve good treasure chances on chambers with tough monsters
  Have minimum magic item count. If not met, distribute them across the dungeon.

The idea of distributing from a centralized location is problematic because you need to be able to regenerate rooms (and in the future, just the treasure).

The odds of a given treasure should change based on level. Strategies:
Option 1:
  Some data that gets used to increase or decrease probability based on difference between level and a target level
Option 2:
  Separate tables for level ranges, or a single file with a probability has with different level ranges and corresponding probabilities
---------------

Bug around chamber placing (likely specificaly place-as-is) on draw_width drawing past max grid width. I think it's due to disagreement about how "width right" works - left of starting square vs left of connector as a whole.
Okay it looks like a problem with the cursor being passed in.
RESOLVED. Turns out initial_cursor_pos provided bad coordinates for chambers facing South and West.

Bug - it is possible for a chamber to get to y=-1, wrapping around to the other end of the grid.
Okay now _this_ may be due to disagreement about how "width right" works.
RESOLVED (I think). Tricky to reproduce, but I believe I forgot to remove "-1" modifiers for proposal checks when length point is past length threshold.

Bug - there's something wacky chamber logic issue causing width to become 1.
RESOLVED . There was a problem where the length prior to shortening is used when placing as-is or generating proposals, which caused proposals to examine areas off of the map and finding collisions on both sides.

Bug - failed doors and connectors can create an odd case where one side of a wall is a connector and the other is a wall.
I'd like to, based on logic and a random chance, either close it off and have both sides be walls, or open it up and have both sides be doors/connectors.
RESOLVED. I now have new logic causing chambers and passages to more explicitly fail when they can't do anything, and cause the connector to treat itself as blocked and behave accordingly

Bug - Allowing objects to connect with existing objects can create a stack overflow by recursing to map objects that have already been recursed to.
RESOLVED. I added a has_incomplete_connectors? method and used it to only recurse to passages that still have incomplete connectors.

Bug - Array wraparound issue can (at least) cause failures connecting two existing map objects together. When a passage checks to see if it can connect forward on conflict, if it's at the edge of the map it can end up checking negative-numbered grid elements, which by default wrap around to the last array value. This caused an edge case where the map thought it could connect to an object on the other side of the map where really it was at the edge of the map and needed to be walled off.
RESOLVED. Now the map.square function returns nil if x or y are below 0, instead of returning a grid value that wraps around the map.

Bug - It is possible to end up with 5-foot corridors. This may be a result of a chamber overlapping a corridor or some other odd undesired behavior. This can cause a 2-width connector to only have 1 of the two squares of the resulting object connect back.
RESOLVED PROBABLY. After fixing numerous other positioning bugs, this has yet to reappear.

Bug - In a Tee passage, if the left passage ends up blocked, it doesn't wall off correctly. It ends up with a connector instead, which is not respected by the chamber on the other side.
RESOLVED. 

Bug - Chambers can choose an exit proposal in which only half of the resulting passage connects properly to the room. This was seen where a proposal for a right-hand exit (south) was chosen with an x-value of 0 with a passage; since the passage width draws right, the second square of the passage width was at x -1 for the chamber. This is almost reasonably valid, but the passage has a connector on the bit that juts out, leading into solid rock. It appears to be capable of causing more serious exit behavior as well, based on a more bizarre case that included the same symptom that I find difficult to describe (5-foot doors where they weren't supposed to be, etc).
RESOLVED. same validity checkas as below probably resolved this one.

Bug - Door (or probably connector) ends up at the edge of a chamber and half of it wraps around to the other side of the chamber. Likely the same bug as immediately above.
RESOLVED. A check is made for coordinate validity that should prevent this from happening again.

Bug - A chamber with a door leading to nowhere crashed the application when clicked on: connector.rb:37:in `exit_string': undefined method `name' for nil:NilClass
RESOLVED. Now the buggy exit will simply say it leads nowhere. The underlying bug may still exist, however. Also, I haven't seen this again since resolving a large handful of other bugs in the ballpark.

Bug - in the UI, some map objects repeat their exit descriptions the more they are clicked on. Other map objects do not have this problem. I don't yet know what differentiates them.
RESOLVED. The bug was using the concat method to include doors in the total exit count, in map_objects.exits() and map_objects.all_connectors(). I used the + operator instead.

Bug - the coordinates of the starting connector in the exits list need to be mirrored to correctly identify where the connector is from the perspective of the map object

Bug - If the map object title is in edit mode when switching map objects, it remains in edit mode with the previous map object's text.
RESOLVED PARTIALLY. It's no longer in edit mode and it shows the correct text, but for some reason it retains the "edit mode" color.

Bug - GUI crashes when Enter is pressed outside the context of the dungen title
RESOLVED. Now the field will only execute logic if it has focus, which will only happen if it's clicked into.

Bug - Chamber exits accidentally overlap with each other. When this happens one of them fails to lead anywhere because the other one has already done so, and ends up walling itself, and part of the other connector, off.
RESOLVED. The map square, which was used in the validity check that would prevent this, was outside the loop it needed to be in, causing only the leftmost square to be checked for a wall.

Bug - It appears to be possible for a map object to overlap with another, causing strange architecture and wall that don't match.
RESOLVED. Due to resolving several other, more specific bugs.

Bug - When two passage run up against each other head on, if one has a connector that isn't yet explored (possible if the passage is the result of a chamber exit, I think?), the other may be able draw into that passage (and then fail to connect). Then later, the original passage gets its connector explored and sure enough, it can't build anything out so it walls off, creating a wall in the middle of the passage that pushed through it. This source of this bug, and possibly others, is that these passages get created separately from the usual map.add_passage code, so they don't get drawn on the map yet. So what can happen is, the exit passage gets created but not drawn on the map, an earlier exit branches out in a way that blocks the passage, then the exit passage gets drawn on the map, overlapping whatever is there. That's why we sometimes see earlier passages overlapping later map objects.
To fix this, I need to make sure the passage gets drawn on the map as soon as it's placed, but this could be tricky. The alternative is to allow the passage to be blocked, and never draw it if that happens.
Idea: Drawing it as soon as it's placed may be easy, but the easy route makes me feel uneasy, since it keeps the draw logic as something that allows overlap, should other issues have similar difficulties. Another option would be to make map.add_passage smarter. It can use a method that checks whether the object can be drawn, and if it can't, remove all possible connections to it (and use blocked connector behavior) and remove the object entirely (logging that it is doing so).
RESOLVED. Now passages wall off if the connecting draw step fails.

Bug - Chamber attempts to place an exit to the North, but the cursor it uses is 2 squares away from the Northern row, causing it to incorrectly decide an exit could not be placed.
RESOLVED. Put in code to address this issue (length and width get reversed when handling exits orthogonal to the room facing), haven't noticed the problem pop back up.

Bug - It is possible to run into a stack overflow.
/home/whitemage/Dropbox/rpg_utils/dungeon_generator/lib/map.rb:109:in `block (2 levels) in draw_map_object': stack level too deep (SystemStackError)
  from /home/whitemage/Dropbox/rpg_utils/dungeon_generator/lib/map.rb:107:in `each'
  from /home/whitemage/Dropbox/rpg_utils/dungeon_generator/lib/map.rb:107:in `each_with_index'
  from /home/whitemage/Dropbox/rpg_utils/dungeon_generator/lib/map.rb:107:in `block in draw_map_object'
  from /home/whitemage/Dropbox/rpg_utils/dungeon_generator/lib/map.rb:106:in `each'
  from /home/whitemage/Dropbox/rpg_utils/dungeon_generator/lib/map.rb:106:in `each_with_index'
  from /home/whitemage/Dropbox/rpg_utils/dungeon_generator/lib/map.rb:106:in `draw_map_object'
  from /home/whitemage/Dropbox/rpg_utils/dungeon_generator/lib/map.rb:87:in `add_passage'
  from /home/whitemage/Dropbox/rpg_utils/dungeon_generator/lib/map_generator.rb:122:in `generate_passage_recursive'
   ... 10332 levels...
  from /home/whitemage/Dropbox/rpg_utils/dungeon_generator/lib/dungeon_generator_gui.rb:146:in `block in menu_bar'
Gotten after infinite repetition of these lines:
I, [2020-05-05T00:40:09.681618 #10445]  INFO -- : Incomplete for Passage 10: 0 connectors, 1 doors
I, [2020-05-05T00:40:09.681632 #10445]  INFO -- : Found existing connected map object
I, [2020-05-05T00:40:09.681646 #10445]  INFO -- : Type: Passage
I, [2020-05-05T00:40:09.681984 #10445]  INFO -- : Incomplete for Passage 2: 0 connectors, 1 doors
I, [2020-05-05T00:40:09.681996 #10445]  INFO -- : Found existing connected map object
I, [2020-05-05T00:40:09.682009 #10445]  INFO -- : Type: Passage
I, [2020-05-05T00:40:09.682392 #10445]  INFO -- : No incomplete connectors or doors for Passage 4
I, [2020-05-05T00:40:09.682403 #10445]  INFO -- : Found existing connected map object
I, [2020-05-05T00:40:09.682416 #10445]  INFO -- : Type: Passage
RESOLVED. I haven't seen this pop up since fixing several other positioning bugs.

Bug - Once, a tee, lined up to the edge of the map, had a missing wall where its right branch should've failed to draw forward (into the edge of the map) and walled itself off.
RESOLVED. blocked_connector_behavior was using the wrong cursor to try to make the wall. I fixed it.

Bug - Passage A gets connector A and B. Connector A gets explored first, which ultimately leads to Passage B, which charges directly into Passage A. Passage B gets blocked, believes it can't connect forward because the other end has a connector, not a wall, and walls itself off. Later, Passage A's Connector B gets explored. It is now up against Passage B. Randomly, it decides to connect forward, which it can do because Passage B walled off. It then creates a reciprocal connection back to Passage A, which removes Passage B's wall. This is where things get weird. It creates a new connector for Passage B facing North, but it's at the wrong x-coordinate (35 instead of 34). Then for some reason it tries to add a passage right there, fails, and walls off Passage A.
The x-coordinate is off because I made direction flexible. I should just calculate it correctly instead. The reason it walled off is because I introduced a bug after the latest commit, in which, when a passage returns in failure, the map's add_passage method will wall it off and remove the connection. Currently when a passage fails to get created because it's immediately blocked, it ends in failure (this is reasonable; the passage in question failed to place). So the add_connector logic is being overzealous.
RESOLVED. Now, the passage only walls off if it fails to draw (as opposed to if it fails to draw or fails to create).

Bug - This seems to be a double-header. First of all, after blocked_connector_behavior creates a door (or connector, probably), generate_passage_recursive then tries to generate beyond it. It does catch that there's already an attached map object so maybe this is okay, but then it runs into the other problem - when the already-attached map object is a chamber, it still thinks it's a passage due to the wonky catch-all else conditional. So it then tries to add the chamber as a passage - bad both because it isn't a passage, and because it's already drawn.
RESOLVED. Now, map objects keep track of whether they have been drawn, and the generator skips any connector that connects to an already-drawn map object.

Bug - x coordinates are showing up with .5s for some reason in the gui.
RESOLVED. For some reason cursor was ending up with floats for its map_x and map_y. I forced them into integers, but am not entirely sure if I'm hiding some weirder problem.

Bug - map objects are entering the map.map_objects array twice most of the time.
RESOLVED. They were getting added by map_object.initialize, then again explicitly by map methods. I removed the line from map_object.initialize.

Bug - It is possible to achieve 0-monster encounters. Blocking these isn't too difficult, but this may also indicate a problematic encounter block or problematic code around figuring out what monsters are allowed based on XP.
I, [2020-11-15T00:35:36.425107 #3554095]  INFO -- : Adding minimum monsters
I, [2020-11-15T00:35:36.425292 #3554095]  INFO -- : Adding monsters with strategy: Chaos
I, [2020-11-15T00:35:36.425406 #3554095]  INFO -- : There are no more available monsters in XP range
category:
I, [2020-11-15T00:35:36.427214 #3554095]  INFO -- : Monster group created:
I, [2020-11-15T00:35:36.427386 #3554095]  INFO -- :   Monsters:
I, [2020-11-15T00:35:36.427489 #3554095]  INFO -- :   XP: 0
I, [2020-11-15T00:35:36.427627 #3554095]  INFO -- :   Challenge: Trivial

Bug - Re-generate encounter operation occasionally produces the exact same encounter as before, even when it is so specific that the odds for it are near-impossible. E.g.
{:description=>"Monster (random creature) with treasure", :hazards=>[], :monsters=>[#<Encounter:0x0055aa7ff50c10 @monster_groups=[[#<Monster:0x0055aa7ff50760 @name="Tlincalli", @size="large", @type="monstrosity", @alignment="ne", @challenge=5, @xp=1800, @book="Volo's Guide to Monsters", @page=193>, #<Monster:0x0055aa7f6e9298 @name="Tlincalli", @size="large", @type="monstrosity", @alignment="ne", @challenge=5, @xp=1800, @book="Volo's Guide to Monsters", @page=193>, #<Monster:0x0055aa7f649fb8 @name="Tlincalli", @size="large", @type="monstrosity", @alignment="ne", @challenge=5, @xp=1800, @book="Volo's Guide to Monsters", @page=193>, #<Monster:0x0055aa7f473158 @name="Tlincalli", @size="large", @type="monstrosity", @alignment="ne", @challenge=5, @xp=1800, @book="Volo's Guide to Monsters", @page=193>, #<Monster:0x0055aa7f3a4a10 @name="Tlincalli", @size="large", @type="monstrosity", @alignment="ne", @challenge=5, @xp=1800, @book="Volo's Guide to Monsters", @page=193>, #<Monster:0x0055aa7f2c09f0 @name="Tlincalli", @size="large", @type="monstrosity", @alignment="ne", @challenge=5, @xp=1800, @book="Volo's Guide to Monsters", @page=193>], [#<Monster:0x0055aa7f0d70f8 @name="Drow Mage", @size="medium", @type="humanoid", @alignment="ne", @challenge=7, @xp=2900, @book="Monster Manual", @page=129>, #<Monster:0x0055aa7f03b7c0 @name="Drow Elite Warrior", @size="medium", @type="humanoid", @alignment="ne", @challenge=5, @xp=1800, @book="Monster Manual", @page=128>, #<Monster:0x0055aa7efa0a90 @name="Drow", @size="medium", @type="humanoid", @alignment="ne", @challenge=0.25, @xp=50, @book="Monster Manual", @page=128>, #<Monster:0x0055aa7e3d4888 @name="Drow", @size="medium", @type="humanoid", @alignment="ne", @challenge=0.25, @xp=50, @book="Monster Manual", @page=128>, #<Monster:0x0055aa7e1acfb0 @name="Drow Elite Warrior", @size="medium", @type="humanoid", @alignment="ne", @challenge=5, @xp=1800, @book="Monster Manual", @page=128>, #<Monster:0x0055aa7e0b7b78 @name="Drow Elite Warrior", @size="medium", @type="humanoid", @alignment="ne", @challenge=5, @xp=1800, @book="Monster Manual", @page=128>, #<Monster:0x0055aa7dfa7be8 @name="Drow Mage", @size="medium", @type="humanoid", @alignment="ne", @challenge=7, @xp=2900, @book="Monster Manual", @page=129>]], @probability=4, @xp_threshold_target=:hard, @relationship="Captured by">], :obstacles=>[], :traps=>[], :treasure=>[#<TreasureStash:0x0055aa804bae58 @coins={"gp"=>121}, @valuables=[], @items=[#<Item:0x0055aa8041d9c8 @name="Flask", @worth="2 cp">, #<Item:0x0055aa804756f0 @name="Quiver", @worth="1 gp">, #<Item:0x0055aa804497d0 @name="Spikes, iron (10)", @worth="1 gp">]>], :tricks=>[]}
[["gp", 121]]

Bug - there may be code that behaves inappropriately with fetch since I didn't know that intentionally-set nil will cause it to fail to default. I should take a peek at where I use the construct and make sure I used it correctly.

Project tracking:

- Passage Instructions: 95%
-- Chance of secret door
- Connecting Passages: 100%
- Chambers: 90%
-- Initial descriptions
-- Circles
- Putting passages on map: 100%
- Collision handling: 100%
- Stairs: 80%
-- Floor instructions
- Multiple Levels: 0%
- Chamber Flavor: 0%
- Doors: 90%
-- Secret Doors
-- False Door with Trap

TODO:
  Chambers:
    - Pillars
    - Circular chambers (probably won't get to)
    - Trapezoidal chambers (probably won't get to)
    - Octagonal chambers (probably won't get to)
  Passages:
    - 5-foot passages
  Map:
    - Starting Area
    - 4-way intersection (starting area)
    - Stairs
    - False door with trap
  GUI:
    - Highlight map object on selection
    - Ability to add/remove connectors/doors
    - Interactive step-by-step map generator
  Flavor:
    - Door material
    - Chamber purpose
    - Chamber contents
  Extra:
    - Loot
    - Inhabitants
    - Traps
    - Export to SVG

Roadmap Order:
- DONE - Starting Areas (excluding the difficult ones)
- DONE - Stairs
- DONE - Encounters - Multiple monster groups & relationships
- DONE - Encounters - Smarter encounter selection (pick from n encounters)
- DONE - Encounters - Allow special encounters regardless of xp if flag is on
- DONE - Treasure
- DONE - Treasure - Add adventuring gear and tools tables
- DONE - Treasure - All levels' treasure tables
- DONE - Treasure - Random types of magical weapons
- DONE - Treasure - Random spells for spell scrolls
- DONE - Add additional content combo possibilities for chambers
- DONE - Chamber Purpose
- DONE - Chamber Features
- DONE - Features - Specify book/scroll
- DONE - Features - Allow features to contain other features
- DONE - Door types
- DONE - Encounters - Show XP threshold for encounters in UI
- DONE - Encounters - Use "Roll" strategy on special encounters
- DONE - Treasure - Set treasure chances based on room contents
- DONE - Features - Allow chamber types to be more likely to contain certain features
- DONE - Contents - Allow chamber types to be more likely to contain treasure
- DONE - Contents - Allow chamber types to be more likely to contain traps
- DONE - Contents - Allow chamber types to be more likely to contain monsters
- Encounters - Dominant Inhabitants
- Encounters - Allies
- Ability to reroll specific chamber content categories
- Chamber Noises
- Chamber State
- Encounters - "Order" encounter-building strategy
- Encounters - Increase chance of finish when monster count gets higher
- Encounters - Allow (optionally) a handful of any-level encounters that always use the "Roll" strategy
- Ability to edit chamber contents (this must be split out per content type)
- Passage width