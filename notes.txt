Ideas on creating actual, mappable/mapped 2D dungeon:
- Each passage segment can be stored as a 2D text string representing the open spaces and connection points
- Or they could be represented by instruction, more dynamically handling things like passage width
- Chambers make a lot of sense handled dynamically, though non-rectangular rooms become quite tricky
- Could do both, having the trickier stuff be handled manually
- I need to be able to rotate whatever I end up with
- There probably needs to be a giant 2D array keeping track of everything, so collision detection can work out.
- Ideally there should also be a structure that keeps track of each room/corridor and linking doors, etc.
- I wonder if I should fish out some of my procedural home generation logic, as it did some similar stuff.


Connecting Passages:

Will the logic to add new passages be from map objects or the map? They will be in relation to both.
A map knows all of its objects. What we need to do when adding a passage is:
- Place the connector on the map
- Create the passage
- Rotate the passage as necessary
- Draw the passage on the map
This could be a problem. The passage needs to know what it will collide with *as it is being drawn* so it can
shorten its length to accommodate. Can we rotate as necessary prior to drawing?
Should be easy, just gotta set the cursor starting position and facing appropriately.
But the passage has to simultaneously understand the current cursor in relation to the map object grid and
the map grid at the same time. If a beginning relationship is established this should be possible.
Perhaps that relationship is established from the initial placement of the cursor? Perhaps the cursor could
get map_x and map_y functions that can use that relationship, so the cursor can tell you its position from
either reference.

Thinking this through:

On a 2-width passage pointing East, a cursor's initial coordinates are (-1, 10) (this will change based on width but we can account for this)
Let's say this is place on the map at (15,15). Let's call the cursor's offset (16, 5) and see what happens.
This means (x, y) on the cursor returns (-1, 10),
and (map_x, map_y) returns (15, 15) if those functions just add the offset.
Let's say the cursor then goes forward 1 space. coordinates are (0,10) now, map coordinates are (16,15). I think that works.

It's important to note, though, that the relationship changes if/when we compact the map object.
What if we started compact? As in, each passage dictating size and starting coordinates? Well let's think about whether that's necessary.
The map primarily needs to be able to draw the object. It can only do that if it has an accurate offset.
If we compact, that necessarily changes the offset.
But offset from what? The cursor's offset isn't exactly what we want; we don't want to retrace all the steps in the map object, we want to transplant
the map object's grid onto the map. So we want the offset of the upper-left square of the map object.
Let's say we put the cursor to (0,0) on the map object. The offset (16, 5) would imply that (0,0) on the map_object is (16, 5) on the map.
Is that true? Yes, I believe it is. So the cursor offset and the map_object offset are one and the same.
So let's not compact, but maybe allow a smaller 
We may ultimately want to compact the map itself, though we may run into similar problems.
Setting length and width would have to assume max passage width (40?), and there is no way to set starting coordinates in the yaml because it depends
on width (not to mention facing).




Project tracking:

- Passage Instructions: 75%
-- Chance of secret door
-- Chamber
-- Stairs
- Connecting Passages: 10%
-- Connect logically
-- Connect physically on map
- Putting passages on map: 0%
- Collision handling: 10%
